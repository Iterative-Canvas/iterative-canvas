---
applyTo: "__NOTHING__"
---

# Prompt Input

The `PromptInput` component allows a user to send a message to a large language model. It includes a textarea, a submit button, and a dropdown for selecting the model.

<Preview path="prompt-input" />

## Installation

```sh
npx ai-elements@latest add prompt-input
```

## Usage

```tsx
import {
  PromptInput,
  PromptInputSubmit,
  PromptInputTextarea,
  PromptInputToolbar,
} from "@/components/ai-elements/prompt-input"
```

```tsx
<PromptInput onSubmit={() => {}} className="mt-4 relative">
  <PromptInputTextarea onChange={(e) => {}} value={""} />
  <PromptInputToolbar>
    <PromptInputSubmit
      className="absolute right-1 bottom-1"
      disabled={false}
      status={"ready"}
    />
  </PromptInputToolbar>
</PromptInput>
```

## Usage with AI SDK

Built a fully functional chat app using `PromptInput`, [`Conversation`](/elements/components/conversation) with a model picker:

Add the following component to your frontend:

```tsx filename="app/page.tsx"
"use client"

import {
  PromptInput,
  PromptInputButton,
  PromptInputModelSelect,
  PromptInputModelSelectContent,
  PromptInputModelSelectItem,
  PromptInputModelSelectTrigger,
  PromptInputModelSelectValue,
  PromptInputSubmit,
  PromptInputTextarea,
  PromptInputToolbar,
  PromptInputTools,
} from "@/components/ai-elements/prompt-input"
import { GlobeIcon, MicIcon } from "lucide-react"
import { useState } from "react"
import { useChat } from "@ai-sdk/react"
import {
  Conversation,
  ConversationContent,
  ConversationScrollButton,
} from "@/components/ai-elements/conversation"
import { Message, MessageContent } from "@/components/ai-elements/message"
import { Response } from "@/components/ai-elements/response"

const models = [
  { id: "gpt-4o", name: "GPT-4o" },
  { id: "claude-opus-4-20250514", name: "Claude 4 Opus" },
]

const InputDemo = () => {
  const [text, setText] = useState<string>("")
  const [model, setModel] = useState<string>(models[0].id)

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    sendMessage(
      { text: text },
      {
        body: {
          model: model,
        },
      },
    )
    setText("")
  }

  const { messages, status, sendMessage } = useChat()

  return (
    <div className="max-w-4xl mx-auto p-6 relative size-full rounded-lg border h-[600px]">
      <div className="flex flex-col h-full">
        <Conversation>
          <ConversationContent>
            {messages.map((message) => (
              <Message from={message.role} key={message.id}>
                <MessageContent>
                  {message.parts.map((part, i) => {
                    switch (part.type) {
                      case "text":
                        return (
                          <Response key={`${message.id}-${i}`}>
                            {part.text}
                          </Response>
                        )
                      default:
                        return null
                    }
                  })}
                </MessageContent>
              </Message>
            ))}
          </ConversationContent>
          <ConversationScrollButton />
        </Conversation>

        <PromptInput onSubmit={handleSubmit} className="mt-4">
          <PromptInputTextarea
            onChange={(e) => setText(e.target.value)}
            value={text}
          />
          <PromptInputToolbar>
            <PromptInputTools>
              <PromptInputButton>
                <MicIcon size={16} />
              </PromptInputButton>
              <PromptInputButton>
                <GlobeIcon size={16} />
                <span>Search</span>
              </PromptInputButton>
              <PromptInputModelSelect
                onValueChange={(value) => {
                  setModel(value)
                }}
                value={model}
              >
                <PromptInputModelSelectTrigger>
                  <PromptInputModelSelectValue />
                </PromptInputModelSelectTrigger>
                <PromptInputModelSelectContent>
                  {models.map((model) => (
                    <PromptInputModelSelectItem key={model.id} value={model.id}>
                      {model.name}
                    </PromptInputModelSelectItem>
                  ))}
                </PromptInputModelSelectContent>
              </PromptInputModelSelect>
            </PromptInputTools>
            <PromptInputSubmit disabled={!text} status={status} />
          </PromptInputToolbar>
        </PromptInput>
      </div>
    </div>
  )
}

export default InputDemo
```

Add the following route to your backend:

```ts filename="app/api/chat/route.ts"
import { streamText, UIMessage, convertToModelMessages } from "ai"

// Allow streaming responses up to 30 seconds
export const maxDuration = 30

export async function POST(req: Request) {
  const { model, messages }: { messages: UIMessage[]; model: string } =
    await req.json()

  const result = streamText({
    model: model,
    messages: convertToModelMessages(messages),
  })

  return result.toUIMessageStreamResponse()
}
```

## Features

- Auto-resizing textarea that adjusts height based on content
- Automatic submit button icons based on status
- Support for keyboard shortcuts (Cmd/Ctrl + Enter to submit)
- Customizable min/max height for the textarea
- Flexible toolbar with support for custom actions and tools
- Built-in model selection dropdown
- Responsive design with mobile-friendly controls
- Clean, modern styling with customizable themes
- Form-based submission handling

## Props

### `<PromptInput />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.HTMLAttributes<HTMLFormElement>",
      description: "Any other props are spread to the root form element.",
      isOptional: true,
    },
  ]}
/>

### `<PromptInputTextarea />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.ComponentProps<typeof Textarea>",
      description:
        "Any other props are spread to the underlying Textarea component.",
      isOptional: true,
    },
  ]}
/>

### `<PromptInputToolbar />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.HTMLAttributes<HTMLDivElement>",
      description: "Any other props are spread to the toolbar div.",
      isOptional: true,
    },
  ]}
/>

### `<PromptInputTools />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.HTMLAttributes<HTMLDivElement>",
      description: "Any other props are spread to the tools div.",
      isOptional: true,
    },
  ]}
/>

### `<PromptInputButton />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.ComponentProps<typeof Button>",
      description:
        "Any other props are spread to the underlying shadcn/ui Button component.",
      isOptional: true,
    },
  ]}
/>

### `<PromptInputSubmit />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.ComponentProps<typeof Button>",
      description:
        "Any other props are spread to the underlying shadcn/ui Button component.",
      isOptional: true,
    },
  ]}
/>

### `<PromptInputModelSelect />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.ComponentProps<typeof Select>",
      description:
        "Any other props are spread to the underlying Select component.",
      isOptional: true,
    },
  ]}
/>

### `<PromptInputModelSelectTrigger />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.ComponentProps<typeof SelectTrigger>",
      description:
        "Any other props are spread to the underlying SelectTrigger component.",
      isOptional: true,
    },
  ]}
/>

### `<PromptInputModelSelectContent />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.ComponentProps<typeof SelectContent>",
      description:
        "Any other props are spread to the underlying SelectContent component.",
      isOptional: true,
    },
  ]}
/>

### `<PromptInputModelSelectItem />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.ComponentProps<typeof SelectItem>",
      description:
        "Any other props are spread to the underlying SelectItem component.",
      isOptional: true,
    },
  ]}
/>

### `<PromptInputModelSelectValue />`

<PropertiesTable
  content={[
    {
      name: "[...props]",
      type: "React.ComponentProps<typeof SelectValue>",
      description:
        "Any other props are spread to the underlying SelectValue component.",
      isOptional: true,
    },
  ]}
/>

# Response

The `Response` component renders a Markdown response from a large language model. It uses [Streamdown](https://streamdown.ai/) under the hood to render the markdown.

<Preview path="response" />

## Installation

```sh
npx ai-elements@latest add response
```

## Usage

```tsx
import { Response } from "@/components/ai-elements/response"
```

```tsx
<Response>**Hi there.** I am an AI model designed to help you.</Response>
```

## Usage with AI SDK

Populate a markdown response with messages from [`useChat`](/docs/reference/ai-sdk-ui/use-chat).

Add the following component to your frontend:

```tsx filename="app/page.tsx"
"use client"

import {
  Conversation,
  ConversationContent,
  ConversationScrollButton,
} from "@/components/ai-elements/conversation"
import { Message, MessageContent } from "@/components/ai-elements/message"
import { useChat } from "@ai-sdk/react"
import { Response } from "@/components/ai-elements/response"

const ResponseDemo = () => {
  const { messages } = useChat()

  return (
    <div className="max-w-4xl mx-auto p-6 relative size-full rounded-lg border h-[600px]">
      <div className="flex flex-col h-full">
        <Conversation>
          <ConversationContent>
            {messages.map((message) => (
              <Message from={message.role} key={message.id}>
                <MessageContent>
                  {message.parts.map((part, i) => {
                    switch (part.type) {
                      case "text": // we don't use any reasoning or tool calls in this example
                        return (
                          <Response key={`${message.id}-${i}`}>
                            {part.text}
                          </Response>
                        )
                      default:
                        return null
                    }
                  })}
                </MessageContent>
              </Message>
            ))}
          </ConversationContent>
          <ConversationScrollButton />
        </Conversation>
      </div>
    </div>
  )
}

export default ResponseDemo
```

## Features

- Renders markdown content with support for paragraphs, links, and code blocks
- Supports GFM features like tables, task lists, and strikethrough text via remark-gfm
- Supports rendering Math Equations via rehype-katex
- **Smart streaming support** - automatically completes incomplete formatting during real-time text streaming
- Code blocks are rendered with syntax highlighting for various programming languages
- Code blocks include a button to easily copy code to clipboard
- Adapts to different screen sizes while maintaining readability
- Seamlessly integrates with both light and dark themes
- Customizable appearance through className props and Tailwind CSS utilities
- Built with accessibility in mind for all users

## Props

### `<Response />`

<PropertiesTable
  content={[
    {
      name: "children",
      type: "string",
      description: "The markdown content to render.",
    },
    {
      name: "parseIncompleteMarkdown",
      type: "boolean",
      description:
        "Whether to parse and fix incomplete markdown syntax (e.g., unclosed code blocks or lists).",
      default: "true",
      isOptional: true,
    },
    {
      name: "className",
      type: "string",
      description: "CSS class names to apply to the wrapper div element.",
      isOptional: true,
    },
    {
      name: "components",
      type: "object",
      description:
        "Custom React components to use for rendering markdown elements (e.g., custom heading, paragraph, code block components).",
      isOptional: true,
    },
    {
      name: "allowedImagePrefixes",
      type: "string[]",
      description:
        'Array of allowed URL prefixes for images. Use ["*"] to allow all images.',
      default: '["*"]',
      isOptional: true,
    },
    {
      name: "allowedLinkPrefixes",
      type: "string[]",
      description:
        'Array of allowed URL prefixes for links. Use ["*"] to allow all links.',
      default: '["*"]',
      isOptional: true,
    },
    {
      name: "defaultOrigin",
      type: "string",
      description:
        "Default origin to use for relative URLs in links and images.",
      isOptional: true,
    },
    {
      name: "rehypePlugins",
      type: "array",
      description:
        "Array of rehype plugins to use for processing HTML. Includes KaTeX for math rendering by default.",
      default: "[rehypeKatex]",
      isOptional: true,
    },
    {
      name: "remarkPlugins",
      type: "array",
      description:
        "Array of remark plugins to use for processing markdown. Includes GitHub Flavored Markdown and math support by default.",
      default: "[remarkGfm, remarkMath]",
      isOptional: true,
    },
    {
      name: "[...props]",
      type: "React.HTMLAttributes<HTMLDivElement>",
      description: "Any other props are spread to the root div.",
      isOptional: true,
    },
  ]}
/>

# Streamdown

A drop-in replacement for react-markdown, designed for AI-powered streaming.

## Overview

Formatting Markdown is easy, but when you tokenize and stream it, new challenges arise. Streamdown is built specifically to handle the unique requirements of streaming Markdown content from AI models, providing seamless formatting even with incomplete or unterminated Markdown blocks.

Streamdown powers the [AI Elements Response](https://ai-sdk.dev/elements/components/response) component but can be installed as a standalone package for your own streaming needs.

## Features

- üöÄ **Drop-in replacement** for `react-markdown`
- üîÑ **Streaming-optimized** - Handles incomplete Markdown gracefully
- üé® **Unterminated block parsing** - Styles incomplete bold, italic, code, links, and headings
- üìä **GitHub Flavored Markdown** - Tables, task lists, and strikethrough support
- üî¢ **Math rendering** - LaTeX equations via KaTeX
- üìä **Mermaid diagrams** - Render Mermaid diagrams as code blocks with a button to render them
- üéØ **Code syntax highlighting** - Beautiful code blocks with Shiki
- üõ°Ô∏è **Security-first** - Built on harden-react-markdown for safe rendering
- ‚ö° **Performance optimized** - Memoized rendering for efficient updates

## Installation

```bash
npm i streamdown
```

Then, update your Tailwind `globals.css` to include the following:

```css
@source "../node_modules/streamdown/dist/index.js";
```

This will ensure that the Streamdown styles are applied to your project.

## Usage

### Basic Example

```tsx
import { Streamdown } from "streamdown"

export default function Page() {
  const markdown = "# Hello World\n\nThis is **streaming** markdown!"

  return <Streamdown>{markdown}</Streamdown>
}
```

### With AI SDK

```tsx
"use client"

import { useChat } from "@ai-sdk/react"
import { useState } from "react"
import { Streamdown } from "streamdown"

export default function Page() {
  const { messages, sendMessage, status } = useChat()
  const [input, setInput] = useState("")

  return (
    <>
      {messages.map((message) => (
        <div key={message.id}>
          {message.parts
            .filter((part) => part.type === "text")
            .map((part, index) => (
              <Streamdown key={index}>{part.text}</Streamdown>
            ))}
        </div>
      ))}

      <form
        onSubmit={(e) => {
          e.preventDefault()
          if (input.trim()) {
            sendMessage({ text: input })
            setInput("")
          }
        }}
      >
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          disabled={status !== "ready"}
          placeholder="Say something..."
        />
        <button type="submit" disabled={status !== "ready"}>
          Submit
        </button>
      </form>
    </>
  )
}
```

## Props

Streamdown accepts all the same props as react-markdown, plus additional streaming-specific options:

| Prop                      | Type                        | Default                   | Description                                  |
| ------------------------- | --------------------------- | ------------------------- | -------------------------------------------- |
| `children`                | `string`                    | -                         | The Markdown content to render               |
| `parseIncompleteMarkdown` | `boolean`                   | `true`                    | Parse and style unterminated Markdown blocks |
| `className`               | `string`                    | -                         | CSS class for the container                  |
| `components`              | `object`                    | -                         | Custom component overrides                   |
| `remarkPlugins`           | `array`                     | `[remarkGfm, remarkMath]` | Remark plugins to use                        |
| `rehypePlugins`           | `array`                     | `[rehypeKatex]`           | Rehype plugins to use                        |
| `allowedImagePrefixes`    | `array`                     | `['*']`                   | Allowed image URL prefixes                   |
| `allowedLinkPrefixes`     | `array`                     | `['*']`                   | Allowed link URL prefixes                    |
| `shikiTheme`              | `BundledTheme` (from Shiki) | `github-light`            | The theme to use for code blocks             |
